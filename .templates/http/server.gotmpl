//Code generated by gorpcgen; DO NOT EDIT.

package server

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"net/http"

	coreCtx "github.com/andrskom/gorpcgen/protocol/context"
	coreErrors "github.com/andrskom/gorpcgen/protocol/errors"
	coreModels "github.com/andrskom/gorpcgen/protocol/models"
	serverHandlers "{{ $.HandlersPackage }}"
	"github.com/sirupsen/logrus"
	{{- if $.UseValidation }}
	"github.com/xeipuuv/gojsonschema"
	{{- end }}
)

type HandlersInterface interface {
	{{range $method := .Methods -}}
	{{ $method.Name }}(*coreCtx.Context, *serverHandlers.{{ $method.RequestName }}) (*serverHandlers.{{ $method.ResponseName }}, *coreErrors.Error)
	{{- end}}
}

type MetricsInterface interface {
	APIDurationFunc(string, string, func() (respType coreModels.ResponseType))
}

type Server struct {
	logger     *logrus.Entry
	handlers   HandlersInterface
	mux        *http.ServeMux
	server     *http.Server
	metrics    MetricsInterface
	{{- if $.UseValidation }}
	validators *Validators
	{{- end }}
}

func New(
	logger *logrus.Entry,
	handlers HandlersInterface,
	server *http.Server,
	metrics MetricsInterface,
	{{- if $.UseValidation -}}
	validators *Validators,
	{{- end }}
) *Server {
	return &Server{
		logger:     logger,
		handlers:   handlers,
		mux:        http.NewServeMux(),
		server:     server,
		metrics:    metrics,
		{{if $.UseValidation -}}
		validators: validators,
		{{- end }}
	}
}

func (s *Server) Serve() error {
	{{- if $.UseValidation}}
	if err := s.validators.Check(); err != nil {
		return err
	}
	{{- end }}
	{{- range $index, $method := .Methods }}
	s.mux.HandleFunc("/{{ $.ServiceName }}/{{ $method.Name }}", s.handleFunc("{{ $.ServiceName }}", "{{ $method.Name }}", s.{{ $method.Name }}Call))
	s.logger.Infof("Handle method: '%s'", "{{ $.ServiceName }}/{{ $method.Name }}")
	{{- end}}
	s.server.Handler = s.mux

	s.logger.WithField("addr", s.server.Addr).Info("Serv")
	return s.server.ListenAndServe()
}

type callFunc func(meta *coreModels.RequestMeta, data []byte) *coreModels.Response
{{range $method := .Methods}}
func (s *Server) {{ $method.Name }}Call(meta *coreModels.RequestMeta, data []byte) *coreModels.Response {
	var req serverHandlers.{{ $method.RequestName }}
	if err := json.Unmarshal(data, &req); err != nil {
		return coreModels.NewResponseErr("Unknown", coreErrors.New(coreErrors.CodeBadRequest, "Can't unmarshal request data", err))
	}
	l := s.logger.WithField("requestID", meta.RequestID).WithField("origin", meta.Origin)
	result, errModel := s.handlers.{{ $method.Name }}(coreCtx.NewContext(meta, l), &req)
	if errModel != nil {
		return coreModels.NewResponseErr(meta.RequestID, errModel)
	}
	respBytes, err := json.Marshal(result)
	if err != nil {
		return coreModels.NewResponseErr(meta.RequestID, coreErrors.New(coreErrors.CodeInternal, "Can't marshal response", err))
	}
	return coreModels.NewResponseOK(meta.RequestID, respBytes)
}
{{end}}
func (s *Server) Shutdown(ctx context.Context) error {
	return s.server.Shutdown(ctx)
}

func (s *Server) handleFunc(service string, method string, call callFunc) func(writer http.ResponseWriter, request *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if rec := recover(); rec != nil {
				s.logger.WithField("topic", service+"/"+method).Errorf(
					"Panic in call : %+v",
					rec,
				)
			}
		}()
		s.metrics.APIDurationFunc(service, method, func() (respType coreModels.ResponseType) {
			reqBytes, err := ioutil.ReadAll(r.Body)
			if err != nil {
				return s.sendResponse(
					service,
					method,
					w,
					coreModels.NewResponseErr(
						"Unknown",
						coreErrors.New(coreErrors.CodeBadRequest, "Can't read request", err),
					),
				)
			}
			if err := r.Body.Close(); err != nil {
				s.logger.WithError(err).Error("Can't close request body")
			}
			s.logger.
				WithField("method", service+"/"+method).
				WithField("data", string(reqBytes)).
				Info("Request")
			{{if $.UseValidation -}}
			validationRequest, err := gojsonschema.Validate(
				s.validators.GetLoader(method+"Request"),
				gojsonschema.NewBytesLoader(reqBytes),
			)
			if err != nil {
				return s.sendResponse(
					service,
					method,
					w,
					coreModels.NewResponseErr(
						"Unknown",
						coreErrors.New(coreErrors.CodeBadRequest, "Can't validate request", err),
					),
				)
			}
			if !validationRequest.Valid() {
				errs := make([]error, 0)
				fields := make(logrus.Fields)
				fields["method"] = service + "/" + method
				for _, e := range validationRequest.Errors() {
					fields[e.Field()] = e.Description()
					errs = append(errs, errors.New(e.String()))
				}
				s.logger.WithFields(fields).Error("Request validation error")
				return s.sendResponse(
					service,
					method,
					w,
					coreModels.NewResponseErr(
						"Unknown",
						coreErrors.New(coreErrors.CodeBadRequest, "Validation error", err),
					),
				)
			}
			{{- end }}
			var req coreModels.Request
			if err := json.Unmarshal(reqBytes, &req); err != nil {
				return s.sendResponse(
					service,
					method,
					w,
					coreModels.NewResponseErr(
						"Unknown",
						coreErrors.New(coreErrors.CodeBadRequest, "Can't unmarshal request", err),
					),
				)
			}

			resp := call(&req.Meta, req.Data)
			return s.sendResponse(service, method, w, resp)
		})
	}
}

func (s *Server) sendResponse(service string, method string, w http.ResponseWriter, resp *coreModels.Response) (result coreModels.ResponseType) {
	result = resp.Type
	w.WriteHeader(http.StatusOK)
	bytes, err := json.Marshal(resp)
	if err != nil {
		bytes = coreModels.NewJSONMarshallErrResponseBytes(resp.Meta.RequestID)
		result = coreModels.ResponseTypeErr
	}
	{{if $.UseValidation -}}
	topicName := service + "/" + method
	validationResponse, err := gojsonschema.Validate(
		s.validators.GetLoader(method+"Response"),
		gojsonschema.NewBytesLoader(bytes),
	)
	if err != nil {
		s.logger.
			WithFields(logrus.Fields{"err": err, "topic": topicName}).
			Error("Can't validate response")
	} else if !validationResponse.Valid() {
		fields := make(logrus.Fields)
		fields["method"] = topicName
		for _, e := range validationResponse.Errors() {
			fields[e.Field()] = e.Description()
		}
		s.logger.WithFields(fields).Error("Response validation error")
	}
	{{- end}}
	if _, err := w.Write(bytes); err != nil {
		s.logger.WithError(err).Error("Can't write response to response writer")
		result = coreModels.ResponseTypeErr
	}
	s.logger.
		WithField("method", service + "/" + method).
		WithField("data", string(bytes)).
		Info("Response")
	return result
}
{{if $.UseValidation }}
//======================================================================================================================

type Validators struct {
	list          []string
	validatorsMap map[string]gojsonschema.JSONLoader
}

func NewValidators() *Validators {
	v := &Validators{
		validatorsMap: make(map[string]gojsonschema.JSONLoader),
		list: []string{
			{{- range $method := .Methods}}
			"{{ $method.Name }}Request",
			"{{ $method.Name }}Response",
			{{- end }}
		},
	}
	return v
}
{{ range $method := .Methods}}
func (v *Validators) With{{ $method.Name }}Request(loader gojsonschema.JSONLoader) *Validators {
	v.validatorsMap["{{ $method.Name }}Request"] = loader
	return v
}

func (v *Validators) With{{ $method.Name }}Response(loader gojsonschema.JSONLoader) *Validators {
	v.validatorsMap["{{ $method.Name }}Response"] = loader
	return v
}
{{ end }}

func (v *Validators) LoadFromDir(dir string) error {
	return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}
		fileNameArr := strings.Split(info.Name(), ".")
		if len(fileNameArr) != 4 {
			return nil
		}
		if fileNameArr[3] != "json" {
			return nil
		}
		v.validatorsMap[fileNameArr[1]+fileNameArr[2]] = gojsonschema.NewReferenceLoader("file://" + path)
		return nil
	})
}

func (v *Validators) GetLoader(loader string) gojsonschema.JSONLoader {
	return v.validatorsMap[loader]
}

func (v *Validators) Check() error {
	listNotRegistered := make([]string, 0)
	for _, loader := range v.list {
		if _, ok := v.validatorsMap[loader]; !ok {
			listNotRegistered = append(listNotRegistered, loader)
		}
	}
	if len(listNotRegistered) > 0 {
		return fmt.Errorf("you must register contracts for: %+v", listNotRegistered)
	}
	return nil
}
{{- end -}}