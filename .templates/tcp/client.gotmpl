// Code generated by gorpcgen; DO NOT EDIT.

package client

import (
	"bufio"
	"encoding/json"
	"fmt"
	"net"

	"github.com/andrskom/gorpcgen/protocol/errors"
	"github.com/andrskom/gorpcgen/protocol/models"
	serverHandlers "github.com/andrskom/gorpcgen/testservice/handlers"
	"github.com/sirupsen/logrus"
)

type Client struct {
	logger *logrus.Entry
	host   string
	port   string
}

func New(logger *logrus.Entry, host string, port string) *Client {
	return &Client{
		logger: logger,
		host:   host,
		port:   port,
	}
}
{{range $method := .Methods}}
func (c *Client) {{ $method.TitleName }}(
	meta models.RequestMeta,
	requestData *serverHandlers.{{ $method.RequestName }},
) (*serverHandlers.{{ $method.ResponseName }}, *errors.Error) {
	reqDataByte, err := json.Marshal(requestData)
	if err != nil {
		return nil, errors.New(errors.CodeInternal, "Can't marshal request data", err)
	}
	respBytes, errM := c.processRequest("{{ $.ServiceName }}.{{ $method.Name }}", meta, reqDataByte)
	if errM != nil {
		return nil, errM
	}
	var result *serverHandlers.{{ $method.ResponseName }}
	if err := json.Unmarshal(respBytes, &result); err != nil {
		return nil, errors.New(errors.CodeInternal, "Can't unmarshal response", err)
	}
	return result, nil
}
{{end}}
func (c *Client) processRequest(method string, meta models.RequestMeta, reqData []byte) ([]byte, *errors.Error) {
	req := models.TCPRequest{
		Method: method,
		Data: models.Request{
			Meta: meta,
			Data: reqData,
		},
	}
	reqBytes, err := json.Marshal(req)
	if err != nil {
		return nil, errors.New(errors.CodeInternal, "Can't marshal tcp request", err)
	}

	conn, err := net.Dial("tcp", fmt.Sprintf("%s:%s", c.host, c.port))
	if err != nil {
		return nil, errors.New(errors.CodeInternal, "Can't dial connection", err)
	}
	defer func() {
		if errClose := conn.Close(); errClose != nil {
			c.logger.WithError(err).Error("Can't close tcp connection")
		}
	}()

	_, err = conn.Write(append(reqBytes, '\n'))
	if err != nil {
		return nil, errors.New(errors.CodeInternal, "Can't write request to connection")
	}

	responseBytes, err := bufio.NewReader(conn).ReadSlice('\n')
	if err != nil {
		return nil, errors.New(errors.CodeInternal, "Can't read response from connection", err)
	}
	var response models.Response
	if err := json.Unmarshal(responseBytes, &response); err != nil {
		return nil, errors.New(errors.CodeInternal, "Can't unmarshal response")
	}
	switch response.Type {
	case models.ResponseTypeOK:
		return response.Result, nil
	case models.ResponseTypeErr:
		respErr := &errors.Error{}
		if err := json.Unmarshal([]byte(response.Result), &respErr); err != nil {
			return nil, errors.New(errors.CodeInternal, "Can't unmarshal response error", err)
		}
		return nil, respErr
	default:
		return nil, errors.New(errors.CodeInternal, "Unknown type of response")
	}
	return response.Result, nil
}
