// Code generated by gorpcgen; DO NOT EDIT.

package server

import (
	"bufio"
	"encoding/json"
	"fmt"
	"net"
	"strings"

	coreCtx "github.com/andrskom/gorpcgen/protocol/context"
	coreErrors "github.com/andrskom/gorpcgen/protocol/errors"
	coreModels "github.com/andrskom/gorpcgen/protocol/models"
	serverHandlers "github.com/andrskom/gorpcgen/testservice/handlers"
	"github.com/sirupsen/logrus"
)

type HandlersInterface interface {
	Get(*coreCtx.Context, *serverHandlers.GetRequest) (*serverHandlers.GetResponse, *coreErrors.Error)
}

type MetricsInterface interface {
	APIDurationFunc(string, string, func() (respType coreModels.ResponseType))
}

type Server struct {
	logger   *logrus.Entry
	host     string
	port     string
	handlers HandlersInterface
	metrics  MetricsInterface
}

func NewServer(
	logger *logrus.Entry,
	host string,
	port string,
	handlers HandlersInterface,
	metrics MetricsInterface,
) *Server {
	return &Server{
		logger:   logger,
		host:     host,
		port:     port,
		handlers: handlers,
		metrics:  metrics,
	}
}

func (s *Server) Serve() error {
	l, err := net.Listen("tcp", fmt.Sprintf("%s:%s", s.host, s.port))
	if err != nil {
		return err
	}
	defer l.Close()
	for {
		conn, err := l.Accept()
		if err != nil {
			s.logger.WithError(err).Error("Accept tcp error")
			continue
		}
		go s.handleReq(conn)
	}
}


func (s *Server) GetCall(req *coreModels.Request) *coreModels.Response {
	var r serverHandlers.GetRequest
	err := json.Unmarshal(req.Data, &r)
	if err != nil {
		return coreModels.NewResponseErr(
			req.Meta.RequestID,
			coreErrors.New(coreErrors.CodeBadRequest, " data", err),
		)
	}
	resp, errM := s.handlers.Get(coreCtx.NewContext(&req.Meta, s.logger.WithField("merhod", "Test.Get")), &r)
	if errM != nil {
		return coreModels.NewResponseErr(req.Meta.RequestID, errM)
	}
	respBytes, err := json.Marshal(resp)
	if err != nil {
		return coreModels.NewResponseErr(
			req.Meta.RequestID,
			coreErrors.New(coreErrors.CodeInternal, "Can't marshal response", err),
		)
	}
	return coreModels.NewResponseOK(req.Meta.RequestID, respBytes)
}


func (s *Server) handleReq(conn net.Conn) {
	defer conn.Close()
	reqData, err := bufio.NewReader(conn).ReadBytes('\n')
	if err != nil {
		s.logger.WithError(err).Error("Read data from conn, error")
		return
	}
	var req coreModels.TCPRequest
	err = json.Unmarshal(reqData, &req)
	if err != nil {
		s.logger.WithError(err).Error("Can't unmarshal request data")
		return
	}
	s.logger.
		WithField("topic", req.Method).
		WithField("data", req.Data.Meta).
		Info("Request")

	parseRes := strings.Split(req.Method, ".")
	if len(parseRes) != 2 {
		s.logger.WithError(err).Error("Number of parsed values is bad")
		return
	}
	serviceName := parseRes[0]
	methodName := parseRes[1]

	s.metrics.APIDurationFunc(serviceName, methodName, func() coreModels.ResponseType {
		var response *coreModels.Response
		switch req.Method {
		case "Test.Get":
			response = s.GetCall(&req.Data)
		default:
			s.logger.Errorf("Unknown rpc method %s", req.Method)
			return coreModels.ResponseTypeErr
		}
		return s.sendResponse(conn, req.Method, coreModels.ResponseTypeOK, response)
	})
}

func (s *Server) sendResponse(
	conn net.Conn,
	method string,
	responseType coreModels.ResponseType,
	response *coreModels.Response,
) coreModels.ResponseType {
	bytes, err := json.Marshal(response)
	if err != nil {
		bytes = coreModels.NewJSONMarshallErrResponseBytes(response.Meta.RequestID)
	}

	if _, err := conn.Write(append(bytes, '\n')); err != nil {
		s.logger.
			WithField("topic", method).
			WithField("data", string(bytes)).
			WithField("err", err).
			Errorf("Can't publish response to topic %s", method)
		return coreModels.ResponseTypeErr
	}
	s.logger.
		WithField("topic", method).
		WithField("data", string(bytes)).
		Info("Response")
	return responseType
}
